## JavaScript - общие вопросы

1. <details>
   <summary>Что такое JavaScript?</summary>

   JavaScript — это высокоуровневый язык программирования общего назначения с динамической типизацией. Первоначально создан для веб-браузеров, где используется для создания интерактивных веб-страниц: добавления анимаций, обработки пользовательских действий, валидации форм и других динамических функций.

   Сегодня JavaScript применяется далеко за пределами браузера: серверная разработка (Node.js), мобильные приложения (React Native), настольные программы (Electron), игры, IoT-устройства и многое другое. Поддерживает различные парадигмы программирования и является одним из самых популярных языков в мире.
   </details>

2. <details>
   <summary>Какие парадигмы программирования поддерживает JavaScript?</summary>

   JavaScript поддерживает несколько основных парадигм программирования:

   1. **Процедурное программирование**
      - Последовательное выполнение инструкций
      - Использование функций для структурирования кода

   2. **Объектно-ориентированное программирование**
      - Прототипное наследование (уникальная особенность JS)
      - Классы (ES6+) как синтаксический сахар над прототипами
      - Инкапсуляция, наследование, полиморфизм

   3. **Функциональное программирование**
      - Функции как объекты первого класса
      - Замыкания (closures)
      - Функции высшего порядка (map, filter, reduce)
      - Неизменяемость данных (immutability)
      - Каррирование и композиция функций

   4. **Событийно-ориентированное программирование**
      - Обработка событий DOM
      - Event Loop и асинхронность
      - Callbacks, Promises, async/await

   5. **Декларативное программирование**
      - Описание "что делать", а не "как делать"
      - Особенно в современных фреймворках (React, Vue)

   Эта гибкость позволяет разработчикам выбирать подходящий стиль в зависимости от задачи и комбинировать разные подходы в одном проекте.
   </details>

1. <details>
   <summary>Строгий режим (use strict)</summary>

    Строгий режим (strict mode) в JavaScript — это специальный режим работы, который помогает писать более безопасный и качественный код. Включив его, вы активируете дополнительные проверки и ограничения, которые предотвращают распространённые ошибки.

    Примеры:

    <b>Объявление переменных</b>
    без strict mode
    ```javascript
    function withoutStrict() {
      myVariable = 10; // Создается глобальная переменная
      console.log(myVariable); // 10
    }
    withoutStrict();
    console.log(myVariable); // 10 - переменная доступна глобально
    ```
    с strict mode
    ```javascript
    function withStrict() {
      "use strict";
      myVariable = 10; // ReferenceError: myVariable is not defined
    }
    withStrict();
    ```

    <b>Дублирование параметров</b>
    без strict mode
    ```javascript
    function duplicate(a, a) {
      return a; // Возвращает последний параметр
    }
    console.log(duplicate(1, 2)); // 2
    ```
    с strict mode
    ```javascript
    "use strict";
    function duplicate(a, a) { // SyntaxError: Duplicate parameter name not allowed
        return a;
    }
    ```

    <b>Удаление переменных</b>
    без strict mode
    ```javascript
    var x = 10;
    delete x; // false, но не выдает ошибку
    console.log(x); // 10
    ```
    с strict mode
    ```javascript
    "use strict";
    var x = 10;
    delete x; // SyntaxError: Delete of an unqualified identifier
    ```

    <b>Ограничение работы this</b>
    без strict mode
    ```javascript
    function showThis() {
      console.log(this); // `this` ссылается на глобальный объект (window в браузере)
    }
    ```
    с strict mode
    ```javascript
    "use strict";
    function showThis() {
      console.log(this); // `this` будет undefined
    }
    ```

    <b>Использование зарезервированных слов</b>
    Предотвращает использование зарезервированных слов. Такие слова, как implements, interface, package, нельзя использовать в качестве переменных или имён функций.
    с strict mode
    ```javascript
    "use strict";
    var let = 10;      // SyntaxError
    var private = 20;  // SyntaxError
    var interface = 30; // SyntaxError
    ```
   </details>

1. <details>
   <summary>Типы данных в JavaScript?</summary>

   JavaScript имеет два основных типа данных: примитивы и объекты.

    <b>Примитивы:</b>
    Number — числа
    String — строки
    Boolean — логический тип
    Undefined — неопределенное значение
    Null — пустое значение
    Symbol — уникальный идентификатор (ES6)
    BigInt — большие числа (ES2020)

    Важно! Примитивы неизменяемы. Например, методы для строк не изменяют саму строку, а возвращают новую.

    <b>Объект</b>
    Object — объекты, массивы, функции.
    ```javascript
    let user = { name: "John", age: 30 };
    let numbers = [1, 2, 3, 4];
    let func = function() { return "Hello"; };
    ```

    Важно! Объекты — это коллекции данных и функциональности. Они передаются по ссылке.
   </details>

1. <details>
   <summary>Коллекции Set, Map, WeakSet, WeakMap</summary>

    <b>Set</b>
    Set — это коллекция уникальных значений, где каждое значение может появляться только один раз.
    <b>Особенности Set</b>
    Хранит только уникальные значения.
    Значения могут быть любого типа.
    Неупорядоченная структура.

    <b>Map</b>
    Map — это коллекция пар ключ-значение, где ключи могут быть любого типа.
    <b>Особенности Map</b>
    Упорядоченная структура.
    Позволяет использовать объекты в качестве ключей.

    <b>WeakSet</b>
    WeakSet — это коллекция, в которой хранятся только объекты. Эти объекты являются слабо-ссылаемыми, что позволяет сборщику мусора удалять их, если на них нет других ссылок.
    <b>Особенности WeakSet</b>
    Хранит только объекты.
    Нельзя получить размер или перебрать элементы.
    Используется для временного хранения объектов.

    <b>WeakMap</b>
    WeakMap — это коллекция пар ключ-значение, где ключами могут быть только объекты, а значения могут быть любыми. Ключи являются слабо-ссылаемыми, что позволяет сборщику мусора удалять объекты, если на них больше нет ссылок.
    <b>Особенности WeakMap</b>
    Ключами могут быть только объекты.
    Значения могут быть любыми.
    Элементы слабо-ссылаемы, что означает автоматическое удаление из коллекции, если ключ недостижим.
    Нельзя перебрать элементы коллекции или получить её размер.

    | Коллекция | Ключи | Перебор | Сборка мусора |
    |-----------|---------------|---------------|---------|
    | Set | любые | да | обычная |
    | Map | любые | да | обычная |
    | WeakSet | только объекты | нет | слабые ссылки |
    | WeakMap | только объекты | нет | слабые ссылки |

    Weak-коллекции не препятствуют удалению объектов сборщиком мусора, что помогает избежать утечек памяти.
   </details>

1. <details>
   <summary>Разница между EventTarget и Event.currentTarget?</summary>

   В JavaScript при работе с событиями Event.target и Event.currentTarget — это два ключевых свойства объекта события, которые часто путают. Вот их основные различия:

   <b>Event.target</b>
   - Элемент, на котором событие было инициировано (т.е. тот, который фактически вызвал событие)
   - Это может быть дочерний элемент, если событие всплыло (event bubbling) через DOM.

   Пример:
   ```javascript
   <div id="parent">
      <button id="child">Click me</button>
   </div>

   document.getElementById('parent').addEventListener('click', (e) => {
      console.log(e.target.id); // "child" (кнопка, по которой кликнули)
   });
   ```

   Даже если обработчик висит на parent, e.target укажет на button, потому что клик произошёл именно по нему.

   <b>Event.currentTarget</b>
   - Элемент, на котором в данный момент выполняется обработчик события (т.е. тот, на который повешен listener).
   - Всегда совпадает с this в контексте обработчика (если не используется стрелочная функция).

   Пример:
   ```javascript
   <div id="parent">
      <button id="child">Click me</button>
   </div>

   document.getElementById('parent').addEventListener('click', function(e) {
      console.log(e.currentTarget.id); // "parent" (элемент с обработчиком)
      console.log(this.id); // "parent" (то же самое)
   });
   ```

   Здесь currentTarget — это div#parent, потому что обработчик привязан к нему.
   </details>

1. <details>
   <summary>Как запретить изменения свойств для объекта?</summary>

   В JavaScript есть несколько способов запретить изменение свойств объекта, в зависимости от уровня "защиты", который тебе нужен. Вот основные подходы, от слабого к самому строгому:

   ## 1. Object.freeze() (полная заморозка)
   Запрещает:
   - Изменение существующих свойств.
   - Добавление новых свойств.
   - Удаление свойств.
   - Изменение дескрипторов свойств (например, writable, configurable).

   <b>Пример:</b>
   ```javascript
   const obj = { name: "Igor", age: 30 };
   Object.freeze(obj);

   obj.age = 31; // Тихо игнорируется (в strict mode — ошибка)
   obj.city = "Moscow"; // Не добавится
   delete obj.name; // Не удалится

   console.log(obj); // { name: "Igor", age: 30 }
   ```

   Ограничения:
   - Работает только на первом уровне вложенности. Вложенные объекты остаются изменяемыми (используй deepFreeze для рекурсивной заморозки).
   - В non-strict mode изменения просто игнорируются (без ошибок).

   ## 2. Object.seal()
   Запрещает:
   - Добавление новых свойств.
   - Удаление существующих свойств, но позволяет изменять значения существующих свойств (если они writable: true).

   <b>Пример:</b>
   ```javascript
   const obj = { name: "Igor", age: 30 };
   Object.seal(obj);

   obj.age = 31; // Работает (если свойство writable)
   obj.city = "Moscow"; // Не добавится
   delete obj.name; // Не удалится
   ```

   ## 3. Object.preventExtensions()
   Запрещает только добавление новых свойств, но позволяет изменять и удалять существующие свойства.

   <b>Пример:</b>
   ```javascript
   const obj = { name: "Igor" };
   Object.preventExtensions(obj);

   obj.age = 30; // Не добавится
   obj.name = "Ivan"; // Работает
   delete obj.name; // Работает
   ```

   ## 4. Дескрипторы свойств (Object.defineProperty)
   Можно явно запретить изменение конкретных свойств через настройку их дескрипторов:
   - <i>writable: false</i> — запрет на изменение значения.
   - <i>configurable: false</i> — запрет на удаление свойства или изменение его дескрипторов.

   <b>Пример:</b>
   ```javascript
   const obj = {};
   Object.defineProperty(obj, "name", {
      value: "Igor",
      writable: false, // нельзя изменить значение
      configurable: false // нельзя удалить или изменить дескрипторы
   });

   obj.name = "Ivan"; // Игнорируется (или ошибка в strict mode)
   delete obj.name; // Ошибка (нельзя удалить)
   ```

   ## 5. Proxy (перехват изменений)
   Для более гибкого контроля можно использовать <i>Proxy</i>, чтобы бросать ошибки или логировать попытки изменений:

   <b>Пример:</b>
   ```javascript
   const obj = { name: "Igor" };
   const protectedObj = new Proxy(obj, {
      set(target, prop, value) {
         throw new Error(`Изменение свойства "${prop}" запрещено!`);
      },
      deleteProperty(target, prop) {
         throw new Error(`Удаление свойства "${prop}" запрещено!`);
      }
   });

   protectedObj.name = "Ivan"; // Error: Изменение свойства "name" запрещено!
   ```
   </details>

1. <details>
   <summary>Как сделать приватное поле у класса?</summary>

   В JavaScript есть только один способ создать приватные поля (private fields) в классе, чтобы ограничить доступ к ним извне.

   С помощью добавления префикса <i>#</i> к имени поля. Это нативная поддержка приватности в классах.

   <b>Пример:</b>
   ```javascript
   class User {
   #password; // Приватное поле (доступно только внутри класса)

   constructor(name, password) {
      this.name = name;       // Публичное поле
      this.#password = password; // Приватное поле
   }

   checkPassword(guess) {
      return guess === this.#password;
   }
   }

   const user = new User("Igor", "secret123");
   console.log(user.name); // "Igor" (доступно)
   console.log(user.#password); // SyntaxError: Приватное поле недоступно снаружи!
   console.log(user.checkPassword("secret123")); // true
   ```
   <b>Плюсы:</b>
   - Нативная поддержка в современных браузерах и Node.js (ES2022+).
   - Истинная приватность: поле недоступно даже через user['#password'].
   - Поддерживает статические приватные поля (static #count).

   <b>Минусы:</b>
   - Не работает в устаревших окружениях (например, IE или старых версиях Node.js).

   Раньше использовали префикс <i>_</i> для обозначения "приватных" полей, но это просто соглашение, а не настоящая защита.
   ```javascript
   class User {
      constructor(name, password) {
         this.name = name;
         this._password = password; // "Приватное" по соглашению
      }
   }

   const user = new User("Igor", "secret123");
   console.log(user._password); // "secret123" (доступно!)
   ```
   Минусы: нет реальной защиты: поле легко доступно снаружи и подходит только для обозначения намерений (не подходит для безопасности).
   </details>

1. <details>
   <summary>Что такое полифилы и для чего они нужны?</summary>

   <b>Полифилы (polyfills)</b> в JavaScript — это код, который добавляет поддержку современных функций в старые окружения (браузеры или версии Node.js), где эти функции ещё не реализованы нативно.

   JavaScript постоянно развивается: появляются новые методы (например, Array.prototype.flatMap, String.prototype.includes), классы (Promise, WeakMap), или синтаксис (оператор ??). Однако старые браузеры (например, IE11) или устаревшие версии Node.js не поддерживают эти фичи и полифилы позволяют использовать современный код, не ломая его в старых окружениях.
   Полифил проверяет, есть ли функция в окружении, и если нет — подменяет её своей реализацией.

   <b>Пример: Полифил для Array.prototype.includes</b>
   ```javascript
   // Проверяем, существует ли метод includes
   if (!Array.prototype.includes) {
   // Если нет — добавляем свою реализацию
   Array.prototype.includes = function(searchElement, fromIndex) {
      if (this == null) throw new TypeError('"this" is null or not defined');
      const arr = Object(this);
      const len = arr.length >>> 0; // Преобразуем length в беззнаковое 32-битное число
      let start = fromIndex | 0; // Преобразуем fromIndex в целое число
      if (start < 0) start += len;
      for (let i = start; i < len; i++) {
         if (arr[i] === searchElement) return true;
      }
      return false;
   };
   }

   // Теперь работает даже в старых браузерах:
   [1, 2, 3].includes(2); // true
   ```
   </details>

1. <details>
   <summary>Что нельзя заполифилить?</summary>

   В JavaScript не все современные фичи можно заполифилить, например:
   <b>Новые синтаксические конструкции</b> - полифилы не могут добавить поддержку нового синтаксиса, потому что cинтаксис обрабатывается движком JavaScript (например, V8, SpiderMonkey) до выполнения кода, а полифилы работают во время выполнения (runtime), когда код уже распарсен.
   Примеры того, что нельзя заполифилить из новых синтаксических конструкций:
   1. <i>Стрелочные функции (=>).</i> Новый синтаксис для объявления функций. Требует транспайлер (Babel, TypeScript).
   2. <i>class / extends</i> Синтаксический сахар для прототипного наследования. Нужно преобразовать в function.
   3. <i>Деструктуризация ({a, b} = obj)</i> Новый синтаксис для распаковки объектов/массивов.
   4. <i>Оператор ?? (Nullish Coalescing)</i> Новый синтаксис для проверки на null/undefined.
   5. <i>Приватные поля классов (#field)</i> Новый синтаксис для приватных свойств.
   6. <i>Динамический import()</i> Синтаксис для динамических импортов (требует поддержки на уровне движка).

   <b>Новые возможности движка (Engine Features)</b> - Некоторые фичи зависят от внутренней реализации движка и не могут быть эмулированы на уровне JavaScript.
   Пример того, что нельзя заполифилить из новых возможностей движка:
   <i>Proxy</i> Требует поддержки на уровне движка (нельзя эмулировать перехват операций с объектами).

   <b>Глобальные объекты с side-эффектами</b> - Некоторые объекты тесно интегрированы с окружением и их нельзя полностью эмулировать.
   Пример того, что нельзя заполифилить из глобальных объектов с side-эффектами:
   <i>window / globalThis</i> Глобальный объект браузера/Node.js. Нельзя переопределить все его свойства.
   <i>console</i> Можно переопределить console.log, но не все методы (например, console.trace).
   </details>